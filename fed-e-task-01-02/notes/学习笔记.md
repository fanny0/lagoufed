### javascript中的引用和可达
### V8引擎
    是一款主流的JavaScript执行引擎
    采用即时编译
    V8内存设置上限 1.5G 800M{1. 浏览器2.垃圾回收}

### V8 垃圾回收策略---堆区的内存数据
> 采用分代回收思想
> 新生代、老生代
> 针对不同的对象采用不同的算法

V8中常用的GC算法
分代回收
空间复制
标记清除
标记整理
标记增量

## 回收新生代对象
# V8内存分配
> V8内存空间一分为2
> 小空间用于存储新生代对象（32M| 16M）
> 新生代指存活时间较短的对象
# 新生代对象回收实现
> 回收过程采用复制+标记整理
> 新生代内存区分为From和To
> 

## 回收老生代对象
> 右侧
> 64/1.4G, 32/700M

## 实现

> 标记清除、标记整理、增量标记算法
> 首先使用标记清除完成垃圾回收
> 晋升会触发标记整理（采用标记整理进行空间优化）
> 增量标记进行效率优化


##细节对比

> 新生代使用空间换时间
> 老年代不适合复制算法

### Performance
> GC的目的是为了实现内存空间的良性循环
> 良性

### 内存问题的体现
> 页面出现延迟加载或经常性暂停---频繁的垃圾回收---瞬间内存爆掉
> 持续性出现糟糕的性能---内存膨胀
> 性能随时间延长越来越差---内存泄漏

###监控内存的几种方式
> 内向泄漏：内存使用持续升高
> 内存膨胀: 在多数设备上都存在性能问题
> 频繁垃圾回收：通过内存变化图进行分析

### 方式
> 浏览器任务管理器
> TimeLine 时序图记录
> 堆快照查找分离DOm
> 判断是否存在频繁的垃圾回收

### 任务管理器监控内存 shift+ese---判断是否存在问题
### TimeLine记录内存
### 堆快照查找分离DOm
> 堆块照留存JS堆照片
## 什么是分离DOM
> 页面元素存活在DOM树上
> 垃圾对象是的DOM节点
> 分离状态的DOM节点---dom树上移除了，但是js'中还被引用

### 判断是否存在频繁的垃圾回收
## 为什么
> GC工作时应用程序是停止的
> 频繁且过长的GC会导致应用假死
> 用户使用中感知应用卡顿

## 确定
> TimeLime 中频繁的上升下降
> 任务管理器中数据频繁的增加减小  瞬间增大瞬间减小

## Performance总结
### 代码优化介绍
> 本质上就是采集大量的执行样本进行数学统计和分析
> 使用基于Benchmark.js的https://jsperf.com/完成
###jsperf 使用流程
### 慎用全局变量
> 全局变量定义在全局执行上下文，是所有作用域链的顶端
> 全局执行上下文一直存在于上下文执行栈，直到程序退出
> 如果某个局部作用域出现了同名变量会遮蔽或污染全局

### 缓存全局变量
> 将使用中无法避免的全局变量缓存到局部变量中

### 通过原型新增方法
> 
### 避开闭包陷阱
### 避免属性访问方法使用
### for循环优化
## 选择最优的循环方式
> forEach
> for 
> for in 

### 文档碎片化优化节点
> 会造成回流和重绘
### 克隆优化节点
### 直接替换new Object





