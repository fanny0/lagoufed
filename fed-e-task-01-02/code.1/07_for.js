//javascript 的引用和可达

const objGroup = ( obj1, obj2 ) => {
    obj1.next = obj2
    obj2.prev = obj1

    return {
        o1: obj1,
        o2: obj2
    }
}

let obj = objGroup({name: 'obj1'}, {name: 'obj2'})
console.log(obj)

//GC算法--引用计数、标记清除、标记整理、分代回收（V8）
//GC是啊垃圾回收机制的简写
//能找到内存中的垃圾，
//程序中不在需要使用的对象
//程序中
/*
    引用计数算法
    核心思想： 设置引用数，判断当前引用数是否是0
    引用计数器
    引用关系改变时修改引用数
    引用数字为0是立即回收

    优缺点
    1. 发现垃圾立即回收
    2. 最大限度减少程序暂停

    1. 无法回收循环引用的对象
    2. 时间开销大--资源消耗大
    实现原理
*/
/*
    标记清除算法的原理
    核心思想：分标记和清除二个阶段完成
    
    遍历所有对象找标记活动对象
    遍历所有对象清除没有标记对象

    优点： 解决对象循环引用的回收
    缺点：空间胡碎片化----地址不连续，浪费空间
        不会立即回收垃圾对象--清除的时候程序是停止工作的
    实现原理
*/
/*
    标记整理
    核心思想：整理成相对连续的
    

    优点： 解决空间碎片化
    缺点：不会立即回收垃圾对象
    实现原理
*/
/*
    分代回收的原理
    核心思想：分标记和清除二个阶段完成
    
    遍历所有对象找标记活动对象
    遍历所有对象清除没有标记对象

    优点： 解决对象循环引用的回收
    缺点：空间胡碎片化----地址不连续
    实现原理
*/